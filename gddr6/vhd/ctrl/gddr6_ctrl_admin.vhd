-- Admin command generation

-- Generates precharge, activate, and refresh commands as required.  Inputs come
-- from the following sources:
--  * Open requests generated by read/write requests to a bank which is not open
--    on the requested row.  These are serviced first.
--  * Lookahead requests for read and write requests.  These are serviced next.
--  * Refresh requests.  If refresh requests are delayed for too long the
--    refresh engine is able to stall the processing of commands.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.support.all;

use work.gddr6_ctrl_command_defs.all;
use work.gddr6_ctrl_core_defs.all;

entity gddr6_ctrl_admin is
    port (
        clk_i : in std_ulogic;

        -- Request to open bank.  Serviced first
        bank_open_i : in bank_open_t;
        -- Filtered lookahead request
        lookahead_i : in bank_open_t;
        -- Refresh requests, serviced and acknowledged when free
        refresh_i : in refresh_request_t;
        refresh_ready_o : out std_ulogic := '0';

        -- Banks status
        status_i : in banks_status_t;

        -- Admin command with completion handshake
        admin_o : out banks_admin_t := IDLE_BANKS_ADMIN;
        admin_ok_i : in std_ulogic;

        command_o : out ca_command_t;
        command_valid_o : out std_ulogic := '0'
    );
end;

architecture arch of gddr6_ctrl_admin is
    signal admin_ready : std_ulogic := '0';
    signal admin_out : banks_admin_t := IDLE_BANKS_ADMIN;

    signal bank_open : bank_open_t := IDLE_OPEN_REQUEST;
    signal refresh : refresh_request_t := IDLE_REFRESH_REQUEST;

    type state_t is (
        IDLE,
        START_PRE_ACT, WAIT_PRE_ACT,
        START_PRE_REF, WAIT_PRE_REF,
        WAIT_IDLE);
    signal state : state_t := IDLE;

    -- Keep track of the last bank activated so that we can block lookahead from
    -- changing this bank.
    signal last_bank_activated : unsigned(3 downto 0);
    signal allow_lookahead : std_ulogic;

    -- Keep track of bank request completions
    signal bank_open_done : std_ulogic := '0';
    signal lookahead_done : std_ulogic := '0';


    -- Block back to back admin commands
    function guard(admin : banks_admin_t; blocked : std_ulogic)
        return banks_admin_t
    is
        variable result : banks_admin_t;
    begin
        result := admin;
        result.valid := admin.valid and not blocked;
        return result;
    end;

begin
    allow_lookahead <=
        to_std_ulogic(lookahead_i.bank /= last_bank_activated) and
        not lookahead_done;

    process (clk_i)
        procedure update_done_flags is
        begin
            if not bank_open_i.valid then
                bank_open_done <= '0';
            end if;
            if not lookahead_i.valid then
                lookahead_done <= '0';
            end if;

            if state = IDLE then
                if bank_open_i.valid and not bank_open_done then
                    bank_open_done <= '1';
                elsif lookahead_i.valid and allow_lookahead then
                    lookahead_done <= '1';
                end if;
            end if;
        end;

        -- Looks for the next thing to do
        procedure load_next_action is
        begin
            if bank_open_i.valid and not bank_open_done then
                bank_open <= bank_open_i;
                state <= START_PRE_ACT;
            elsif lookahead_i.valid and allow_lookahead then
                bank_open <= lookahead_i;
                state <= START_PRE_ACT;
            elsif refresh_i.valid then
                refresh <= refresh_i;
                refresh_ready_o <= '1';
                state <= START_PRE_REF;
            else
                state <= IDLE;
            end if;
        end;

        procedure start_precharge(
            bank : unsigned; all_banks : std_ulogic := '0') is
        begin
            admin_out <= (
                command => CMD_PRE,
                bank => bank,
                all_banks => all_banks,
                row => (others => '0'),
                valid => '1'
            );
        end;

        procedure start_activate is
        begin
            last_bank_activated <= bank_open.bank;
            admin_out <= (
                command => CMD_ACT,
                bank => bank_open.bank,
                all_banks => '0',
                row => bank_open.row,
                valid => '1'
            );
        end;

        procedure start_refresh is
        begin
            admin_out <= (
                command => CMD_REF,
                bank => '0' & refresh.bank,
                all_banks => refresh.all_banks,
                row => (others => '0'),
                valid => '1'
            );
        end;

    begin
        if rising_edge(clk_i) then
            -- Manage the completion flags
            update_done_flags;

            -- Select appropriate request to service
            case state is
                when IDLE =>
                    -- Wait for an incoming request, switch to the appropriate
                    -- state (START_PRE_ACT or START_PRE_REF) depending on
                    -- selection
                    load_next_action;
                when START_PRE_ACT =>
                    -- Take a tick to check whether the bank needs to be
                    -- precharged first
                    if status_i.active(to_integer(bank_open.bank)) then
                        start_precharge(bank_open.bank);
                        state <= WAIT_PRE_ACT;
                    else
                        start_activate;
                        state <= WAIT_IDLE;
                    end if;
                when WAIT_PRE_ACT =>
                    -- Wait for precharge to complete before activating
                    if admin_ready then
                        start_activate;
                        state <= WAIT_IDLE;
                    end if;
                when START_PRE_REF =>
                    -- Precharging for refresh is a bit more involved.  If we're
                    -- doing an all banks refresh then it's simplest to
                    -- unconditionally precharge all the banks, otherwise we
                    -- have to check two banks
                    refresh_ready_o <= '0';
                    if refresh.all_banks then
                        start_precharge("0000", '1');
                        state <= WAIT_PRE_REF;
                    elsif status_i.active(to_integer(refresh.bank)) then
                        start_precharge('0' & refresh.bank);
                        state <= WAIT_PRE_REF;
                    elsif status_i.active(8 + to_integer(refresh.bank)) then
                        start_precharge('1' & refresh.bank);
                        state <= WAIT_PRE_REF;
                    else
                        start_refresh;
                        state <= WAIT_IDLE;
                    end if;
                when WAIT_PRE_REF =>
                    -- Waiting for each precharge to finish
                    if admin_ready then
                        if refresh.all_banks then
                            start_refresh;
                            state <= WAIT_IDLE;
                        else
                            admin_out.valid <= '0';
                            state <= START_PRE_REF;
                        end if;
                    end if;
                when WAIT_IDLE =>
                    -- Wait for requested action to complete
                    if admin_ready then
                        admin_out.valid <= '0';
                        state <= IDLE;
                    end if;
            end case;

            -- Convert admin request to SG command
            case admin_out.command is
                when CMD_ACT =>
                    command_o <= SG_ACT(admin_out.bank, admin_out.row);
                when CMD_PRE =>
                    if admin_out.all_banks then
                        command_o <= SG_PREab;
                    else
                        command_o <= SG_PREpb(admin_out.bank);
                    end if;
                when CMD_REF =>
                    if admin_out.all_banks then
                        command_o <= SG_REFab;
                    else
                        command_o <= SG_REFp2b(admin_out.bank(2 downto 0));
                    end if;
            end case;
            admin_ready <= admin_ok_i;
        end if;
    end process;

    -- This is a temporary fudge, need to slightly rework the state machine
    -- above to achieve this instead
    admin_o <= guard(admin_out, admin_ready);

    command_valid_o <= admin_ready;
end;
