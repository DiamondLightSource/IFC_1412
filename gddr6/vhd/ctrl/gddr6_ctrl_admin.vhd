-- Admin command generation

-- Generates precharge, activate, and refresh commands as required.  Inputs come
-- from the following sources:
--  * Open requests generated by read/write requests to a bank which is not open
--    on the requested row.  These are serviced first.
--  * Lookahead requests for read and write requests.  These are serviced next.
--  * Refresh requests.  If refresh requests are delayed for too long the
--    refresh engine is able to stall the processing of commands.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.support.all;

use work.gddr6_ctrl_command_defs.all;
use work.gddr6_ctrl_defs.all;

entity gddr6_ctrl_admin is
    port (
        clk_i : in std_ulogic;

        -- Request to open bank.  Serviced first
        bank_open_i : in bank_open_t;
        -- Filtered lookahead request
        lookahead_i : in bank_open_t;
        -- Refresh requests, serviced and acknowledged when free
        refresh_i : in refresh_request_t;
        refresh_ack_o : out std_ulogic := '0';

        -- Banks status
        status_i : in banks_status_t;

        -- Admin command with completion handshake
        admin_o : out banks_admin_t := IDLE_BANKS_ADMIN;
        admin_ack_i : in std_ulogic;

        command_o : out ca_command_t;
        command_valid_o : out std_ulogic := '0'
    );
end;

architecture arch of gddr6_ctrl_admin is
    signal bank_open_in : bank_open_t := IDLE_OPEN_REQUEST;
    signal lookahead_in : bank_open_t := IDLE_OPEN_REQUEST;
    signal bank_open : bank_open_t := IDLE_OPEN_REQUEST;
    signal refresh : refresh_request_t := IDLE_REFRESH_REQUEST;
    signal refresh_ack : std_ulogic := '0';

    -- The admin state machine performs two actions:
    --  1/ Opening a bank required for an active read/write request or a
    --     lookahead: this may involve precharging the target bank before
    --     activating it.
    --  2/ Performing a complete refresh request.  This may involve precharging
    --     one, two, or all banks before issuing the refresh.
    -- The following state transitions are performed:
    --
    --                     START         WAIT
    --             +--->  PRE ACT --->  PRE ACT
    --             |          \            \
    --     +--> IDLE           +------------+---->  WAIT IDLE  -->  IDLE DELAY
    --     |       |          /            /                            |
    --     |       +--->   START  --->   WAIT                           |
    --     |              PRE REF <---  PRE REF                         |
    --     +------------------------------------------------------------+
    type state_t is (
        IDLE,                           -- Waiting for valid request
        START_PRE_ACT, WAIT_PRE_ACT,    -- Open bank for read/write or lookahead
        START_PRE_REF, WAIT_PRE_REF,    -- Refresh
        WAIT_IDLE,                      -- Wait for last command to complete
        IDLE_DELAY);                    -- Let bank open status propagate
    signal state : state_t := IDLE;


    -- Filters open requests that need to be processed
    function check_open(bank_open : bank_open_t; status : banks_status_t)
        return bank_open_t
    is
        variable result : bank_open_t;
        variable bank : natural;
    begin
        bank := to_integer(bank_open.bank);
        result := bank_open;
        result.valid :=
            result.valid and (
                not status.active(bank) or
                to_std_ulogic(status.row(bank) /= bank_open.row));
        return result;
    end;

begin
    process (clk_i)
        -- Looks for the next thing to do
        procedure load_next_action is
        begin
            if refresh_i.valid and refresh_i.priority then
                -- Priority refresh requests override everything else
                refresh <= refresh_i;
                refresh_ack <= '1';
                state <= START_PRE_REF;
            elsif bank_open_in.valid then
                -- Read/Write request is pending
                bank_open <= bank_open_in;
                state <= START_PRE_ACT;
            elsif lookahead_in.valid then
                -- Lookahead request
                bank_open <= lookahead_in;
                state <= START_PRE_ACT;
            elsif refresh_i.valid then
                -- Normal refresh requests are fitted in last
                refresh <= refresh_i;
                refresh_ack <= '1';
                state <= START_PRE_REF;
            else
                state <= IDLE;
            end if;
        end;

        procedure start_precharge(
            bank : unsigned; all_banks : std_ulogic := '0') is
        begin
            admin_o <= (
                command => CMD_PRE,
                bank => bank,
                all_banks => all_banks,
                row => (others => '0'),
                valid => '1'
            );
        end;

        procedure start_activate is
        begin
            admin_o <= (
                command => CMD_ACT,
                bank => bank_open.bank,
                all_banks => '0',
                row => bank_open.row,
                valid => '1'
            );
        end;

        procedure start_refresh is
        begin
            admin_o <= (
                command => CMD_REF,
                bank => '0' & refresh.bank,
                all_banks => refresh.all_banks,
                row => (others => '0'),
                valid => '1'
            );
        end;

    begin
        if rising_edge(clk_i) then
            -- Pipelined checks of incoming open requests to filter out requests
            -- that need no action
            bank_open_in <= check_open(bank_open_i, status_i);
            lookahead_in <= check_open(lookahead_i, status_i);

            -- Select appropriate request to service
            case state is
                when IDLE =>
                    -- Wait for an incoming request, switch to the appropriate
                    -- state (START_PRE_ACT or START_PRE_REF) depending on
                    -- selection
                    load_next_action;
                when START_PRE_ACT =>
                    -- Take a tick to check whether the bank needs to be
                    -- precharged first
                    if status_i.active(to_integer(bank_open.bank)) then
                        start_precharge(bank_open.bank);
                        state <= WAIT_PRE_ACT;
                    else
                        start_activate;
                        state <= WAIT_IDLE;
                    end if;
                when WAIT_PRE_ACT =>
                    -- Wait for precharge to complete before activating
                    if admin_ack_i then
                        start_activate;
                        state <= WAIT_IDLE;
                    end if;
                when START_PRE_REF =>
                    -- Precharging for refresh is a bit more involved.  If we're
                    -- doing an all banks refresh then it's simplest to
                    -- unconditionally precharge all the banks, otherwise we
                    -- have to check two banks
                    refresh_ack_o <= '0';
                    if refresh.all_banks then
                        start_precharge("0000", '1');
                        state <= WAIT_PRE_REF;
                    elsif status_i.active(to_integer(refresh.bank)) then
                        start_precharge('0' & refresh.bank);
                        state <= WAIT_PRE_REF;
                    elsif status_i.active(8 + to_integer(refresh.bank)) then
                        start_precharge('1' & refresh.bank);
                        state <= WAIT_PRE_REF;
                    else
                        start_refresh;
                        state <= WAIT_IDLE;
                    end if;
                when WAIT_PRE_REF =>
                    -- Waiting for each precharge to finish
                    if admin_ack_i then
                        if refresh.all_banks then
                            start_refresh;
                            state <= WAIT_IDLE;
                        else
                            admin_o.valid <= '0';
                            state <= START_PRE_REF;
                        end if;
                    end if;
                when WAIT_IDLE =>
                    -- Wait for requested action to complete
                    if admin_ack_i then
                        admin_o.valid <= '0';
                        -- Acknowledge completion of refresh if appropriate
                        refresh_ack_o <= refresh_ack;
                        refresh_ack <= '0';
                        state <= IDLE_DELAY;
                    end if;
                when IDLE_DELAY =>
                    -- A one tick delay so that the computed bank status is
                    -- fully in step
                    refresh_ack_o <= '0';
                    state <= IDLE;
            end case;

            -- Convert admin request to SG command
            case admin_o.command is
                when CMD_ACT =>
                    command_o <= SG_ACT(admin_o.bank, admin_o.row);
                when CMD_PRE =>
                    if admin_o.all_banks then
                        command_o <= SG_PREab;
                    else
                        command_o <= SG_PREpb(admin_o.bank);
                    end if;
                when CMD_REF =>
                    if admin_o.all_banks then
                        command_o <= SG_REFab;
                    else
                        command_o <= SG_REFp2b(admin_o.bank(2 downto 0));
                    end if;
            end case;
        end if;
    end process;

    -- Admin commands need to be emitted one tick earlier than read/write
    -- commands to compensate for deliberate timing skew elsewhere
    command_valid_o <= admin_ack_i;
end;
