#!/usr/bin/env python

import sys
import argparse
import struct
from collections import namedtuple

from ifc_lib import defs_path
from fpga_lib.driver import driver


class Registers(driver.RawRegisters):
    NAME = 'ifc_1412-mailbox'

    def __init__(self, address = 0):
        super().__init__(self.NAME, address)
        register_defines = defs_path.register_defines(__file__)
        mailbox_defines = defs_path.module_defines('mailbox')
        self.make_registers('TOP', None, mailbox_defines, register_defines)

def open(addr = 0):
    regs = Registers(addr)
    return regs.TOP.MAILBOX


def to_int(s):
    return int(s, 0)

def parse_args():
    parser = argparse.ArgumentParser(description = 'Read/write raw registers')
    parser.add_argument(
        '-a', dest = 'address', default = 0,
        help = 'Set physical address of card.  If not specified then card 0')
    parser.add_argument(
        '-f', dest = 'force', action = 'store_true',
        help = 'Ignore faulty checksum')

    subparsers = parser.add_subparsers(
        dest = 'select',
        help = 'Select read or write, use -h after selection for specific help')

    read_parser = subparsers.add_parser('read',
        description = 'Read from mailbox')
    read_parser.add_argument(
        'mb_address', type = to_int, help = 'Address to read from')

    write_parser = subparsers.add_parser('write',
        description = 'Write to mailbox')
    write_parser.add_argument(
        'mb_address', type = to_int, help = 'Address to write to')
    write_parser.add_argument(
        'values', type = to_int, nargs = '+',
        help = 'Values to write')

    identity_parser = subparsers.add_parser('ident',
        description = 'Return identity')
    identity_parser.add_argument(
        'source', default = 'mmc', choices = ['mmc', 'rtm'], nargs = '?',
        help = 'Select identity to return')

    slot_parser = subparsers.add_parser('slot',
        description = 'Return slot number')

    args = parser.parse_args()
    if args.select is None:
        parser.error("Must specify action")
    return args

def fail(message):
    print(message, file = sys.stderr)
    sys.exit(1)


def read_array(mailbox, message, count):
    result = []
    for n in range(count):
        mailbox._write_fields_wo(
            MSG_ADDR = message, BYTE_ADDR = n, WRITE = 0)
        result.append(mailbox.DATA)
    return result


def read_mailbox(mailbox, address):
    result = ' '.join([
        f'{data:02X}'
        for data in read_array(mailbox, address, 16)])
    print(f'MB[{address:03X}]: {result}')

def write_mailbox(mailbox, message, values):
    for n, value in enumerate(values):
        mailbox._write_fields_wo(
            MSG_ADDR = message, BYTE_ADDR = n, DATA = value, WRITE = 1)


MMC_Message = namedtuple('MMC',
    ['ver', 'product', 'version', 'serial', 'slot'])


def read_mmc_message(mailbox, force):
    data = bytes(read_array(mailbox, 0, 10))
    if not any(data):
        fail('Nothing written to mailbox')
    checksum = sum(data) % 256
    if checksum != 0:
        if force:
            print(f'Invalid checksum 0x{checksum:02x}', file = sys.stderr)
        else:
            fail('Invalid checksum')

    # Decode mailbox according to following structure (all number big endian):
    #   0       Message version
    #   2:1     Product number (1412)
    #   3       Product version
    #   7:4     Product serial number
    #   8       AMC slot
    #   9       Checksum (already checked above)
    mmc = MMC_Message(*struct.unpack('>BHBLB', data[:-1]))
    if not 1 <= mmc.slot <= 12:
        fail(f'Invalid slot number: {mmc.slot}')
    return mmc

def read_identity(mailbox, source, force):
    assert source == 'mmc', 'Only mmc supported at present'

    mmc = read_mmc_message(mailbox, force)
    print(
        f'Ver: {mmc.ver} Product: {mmc.product} v{mmc.version} serial '
        f'{mmc.serial} in slot {mmc.slot}')

def read_slot(mailbox, force):
    mmc = read_mmc_message(mailbox, force)
    print(mmc.slot)


def main():
    args = parse_args()
    mailbox = open(args.address)

    if args.select == 'read':
        read_mailbox(mailbox, args.mb_address)
    elif args.select == 'write':
        write_mailbox(mailbox, args.mb_address, args.values)
    elif args.select == 'ident':
        read_identity(mailbox, args.source, args.force)
    elif args.select == 'slot':
        read_slot(mailbox, args.force)

main()
